#include <catch2/catch_amalgamated.hpp>

#include "sdpb_util/block_mapping/compute_block_grid_mapping.hxx"
#include "sdpb_util/ostream/ostream_vector.hxx"
#include "test_util/diff.hxx"
#include "unit_tests/util/util.hxx"

#include <unordered_set>

using Test_Util::REQUIRE_Equal::diff;

void diff(const Block_Map &a, const Block_Map &b)
{
  DIFF(a.num_procs, b.num_procs);
  DIFF(a.cost, b.cost);
  DIFF(a.block_indices, b.block_indices);
}

std::ostream &operator<<(std::ostream &os, const Block_Map &block_map)
{
  // return os << "block_indices=" << block_map.block_indices
  //           << " num_procs=" << block_map.num_procs
  //           << " cost=" << block_map.cost;
  return os << "{" << block_map.num_procs << ", " << block_map.cost << ", "
            << block_map.block_indices << "}";
}

std::ostream &operator<<(std::ostream &os, const Block_Cost &block_cost)
{
  return os << "{" << block_cost.cost << "," << block_cost.index << "}";
}

namespace
{
  void
  do_test_block_mapping(const size_t procs_per_node, const size_t num_nodes,
                        const std::vector<Block_Cost> &block_costs)
  {
    CAPTURE(block_costs);
    const size_t num_blocks = block_costs.size();

    auto mapping
      = compute_block_grid_mapping(procs_per_node, num_nodes, block_costs);
    INFO("Sanity checks for compute_block_grid_mapping() result");
    CAPTURE(mapping);

    std::unordered_set<size_t> processed_indices;

    REQUIRE(mapping.size() == num_nodes);
    for(const auto &node_mapping : mapping)
      {
        size_t num_procs = 0;
        for(const auto &block_map : node_mapping)
          {
            REQUIRE(block_map.num_procs > 0);

            // Since each block is assigned to a single node,
            // there can be empty nodes if we don't have enough blocks.
            // Otherwise, each process should get some block.
            if(num_blocks >= num_nodes)
              REQUIRE(!block_map.block_indices.empty());

            size_t cost = 0;
            for(auto index : block_map.block_indices)
              {
                CAPTURE(index);
                REQUIRE(index < block_costs.size());
                auto [it, inserted_for_a_first_time]
                  = processed_indices.insert(index);
                REQUIRE(inserted_for_a_first_time);

                cost += block_costs.at(index).cost;
              }
            REQUIRE(cost == block_map.cost);

            num_procs += block_map.num_procs;
          }
        INFO("Mapping should contain procs_per_node processes for each node:");
        REQUIRE(num_procs == procs_per_node);
      }

    INFO("Check that all indices were added to mapping:");
    REQUIRE(processed_indices.size() == num_blocks);
  }
}

TEST_CASE("compute_block_grid_mapping")
{
  if(El::mpi::Rank() != 0)
    return;

  SECTION("Simple unsorted costs")
  {
    // This simple test failed because
    // compute_block_grid_mapping() did not sort block costs.
    // TODO: add more tests
    const size_t procs_per_node = 3;
    const size_t num_nodes = 1;
    std::vector<Block_Cost> block_costs = {{1, 0}, {2, 1}};
    auto mapping
      = compute_block_grid_mapping(procs_per_node, num_nodes, block_costs);

    // TODO in principle, order of Block_Map's in expected result is not fixed.
    // Here we choose the one that is generated
    // by current compute_block_grid_mapping() implementation.
    const decltype(mapping) expected_mapping
      = {{Block_Map(2, 2, {1}), Block_Map(1, 1, {0})}};
    DIFF(mapping, expected_mapping);

    {
      std::sort(block_costs.rbegin(), block_costs.rend());
      mapping
        = compute_block_grid_mapping(procs_per_node, num_nodes, block_costs);
      DIFF(mapping, expected_mapping);
    }
  }

  SECTION("Random")
  {
    size_t num_nodes = GENERATE(1, 2, 5);
    size_t procs_per_node = GENERATE(1, 10, 101);
    size_t num_blocks = GENERATE(1, 2, 30, 1001);

    CAPTURE(num_nodes);
    CAPTURE(procs_per_node);
    CAPTURE(num_blocks);

    std::vector<Block_Cost> block_costs;
    {
      INFO("Generate block_costs");
      block_costs.reserve(num_blocks);
      std::default_random_engine rand_engine;
      std::uniform_int_distribution<size_t> dist(0, num_blocks * 2);
      for(size_t index = 0; index < num_blocks; ++index)
        {
          size_t cost = dist(rand_engine);
          block_costs.emplace_back(cost, index);
        }
    }

    std::vector<int> cost_list;
    cost_list.reserve(block_costs.size());
    for(const auto &block_cost : block_costs)
      {
        cost_list.push_back(block_cost.cost);
      }
    CAPTURE(cost_list);

    do_test_block_mapping(procs_per_node, num_nodes, block_costs);
  }

  // TODO this case was generated by random and failed on MacBook M1.
  // but seems to work on my laptop (WSL+Ubuntu).
  SECTION("corner_case")
  {
    size_t num_nodes = 2;
    size_t procs_per_node = 10;

    CAPTURE(num_nodes);
    CAPTURE(procs_per_node);
    DYNAMIC_SECTION("num_nodes=" << num_nodes
                                 << " procs_per_node=" << procs_per_node)
    {
      std::vector<int> cost_list = {
        1166, 1861, 380,  240,  290,  592,  88,   194,  638,  1314, 878,  170,
        332,  1704, 1026, 552,  1585, 398,  974,  739,  1376, 1411, 1622, 440,
        1107, 57,   1907, 914,  1562, 1156, 723,  666,  701,  311,  214,  259,
        812,  194,  160,  1941, 1973, 42,   1296, 1999, 518,  1954, 1423, 1948,
        1755, 8,    219,  1300, 1794, 991,  1414, 1443, 346,  898,  1420, 221,
        208,  1958, 1534, 1171, 1180, 1553, 1110, 384,  1627, 1131, 1891, 253,
        782,  124,  879,  34,   1167, 1518, 125,  1424, 1211, 641,  711,  779,
        648,  590,  1265, 1953, 914,  449,  815,  225,  377,  120,  662,  277,
        1375, 722,  1826, 34,   1042, 860,  1635, 483,  1550, 251,  32,   1588,
        1272, 1292, 1314, 1614, 1999, 1838, 1876, 23,   874,  537,  1105, 651,
        302,  755,  119,  1682, 603,  1891, 883,  499,  896,  1400, 1469, 243,
        1705, 1641, 203,  1539, 1194, 866,  530,  369,  1753, 849,  649,  1149,
        1012, 405,  473,  1185, 241,  1226, 682,  1411, 662,  62,   964,  710,
        610,  1610, 637,  225,  1394, 386,  1453, 1056, 287,  1558, 762,  497,
        290,  867,  1680, 334,  1180, 1514, 1344, 1842, 1752, 1944, 195,  22,
        1306, 484,  349,  1236, 1239, 155,  67,   372,  330,  1518, 758,  1178,
        133,  1389, 616,  325,  161,  1846, 1313, 1092, 501,  1312, 1820, 1043,
        167,  627,  360,  9,    416,  1565, 1805, 944,  1217, 1598, 1699, 1,
        139,  1483, 1620, 8,    15,   380,  424,  1157, 329,  1378, 62,   468,
        300,  599,  629,  1818, 1300, 31,   164,  270,  1044, 1010, 381,  205,
        870,  1609, 1827, 1249, 1156, 1887, 604,  539,  733,  906,  1280, 628,
        25,   1416, 1306, 1694, 1486, 749,  496,  170,  1843, 1955, 924,  628,
        1463, 1614, 1149, 1185, 345,  1822, 1698, 577,  1772, 1686, 121,  1075,
        1746, 808,  1070, 1479, 1387, 155,  1537, 906,  1068, 912,  1998, 1055,
        1843, 1924, 1700, 587,  1346, 1064, 1030, 1936, 660,  1144, 1140, 583,
        1400, 526,  1869, 386,  253,  1093, 1023, 719,  375,  52,   1646, 207,
        922,  1871, 396,  281,  1543, 395,  1613, 554,  1699, 107,  1973, 376,
        847,  825,  1370, 1208, 424,  1643, 1503, 1554, 584,  1991, 261,  898,
        1869, 1101, 214,  647,  1319, 706,  1576, 1659, 212,  1561, 573,  1082,
        552,  966,  551,  967,  518,  1397, 238,  536,  501,  958,  603,  428,
        1190, 151,  1613, 1767, 266,  692,  1521, 1298, 1407, 1015, 526,  27,
        1487, 1338, 625,  1239, 697,  1059, 572,  31,   350,  92,   206,  1209,
        1354, 1749, 1444, 1544, 380,  1004, 679,  1558, 675,  1856, 604,  862,
        1599, 1723, 757,  156,  1116, 280,  1089, 1646, 568,  842,  1594, 953,
        208,  287,  1444, 693,  1716, 1947, 1474, 465,  1049, 1453, 145,  1043,
        867,  702,  1001, 763,  1266, 1489, 1151, 7,    28,   1273, 488,  1485,
        274,  1923, 1742, 283,  1198, 1101, 217,  792,  993,  361,  359,  1675,
        1281, 917,  1259, 632,  763,  1422, 590,  1835, 1274, 96,   1720, 19,
        1903, 1283, 1998, 887,  1697, 1081, 1115, 438,  1038, 247,  795,  466,
        1738, 1257, 1795, 1357, 1127, 355,  1340, 1796, 694,  515,  765,  495,
        38,   98,   486,  1682, 480,  1063, 1080, 1815, 709,  1847, 278,  330,
        1342, 788,  1601, 452,  1091, 849,  1394, 1814, 1038, 127,  353,  1274,
        360,  1097, 144,  1835, 772,  572,  1755, 793,  49,   185,  683,  191,
        973,  1017, 781,  1718, 762,  1950, 455,  734,  401,  731,  1038, 672,
        1991, 1345, 1627, 418,  11,   1556, 612,  1464, 875,  832,  1716, 1963,
        740,  1627, 221,  3,    1720, 405,  712,  753,  968,  127,  909,  1347,
        1756, 171,  579,  623,  526,  896,  388,  998,  494,  106,  901,  1511,
        195,  444,  1900, 478,  149,  822,  1732, 764,  63,   442,  228,  735,
        1288, 429,  602,  637,  1070, 1749, 1846, 269,  69,   1591, 686,  382,
        1936, 101,  1410, 866,  1647, 610,  1854, 1937, 1079, 1172, 315,  1318,
        1817, 1138, 1968, 188,  221,  146,  1189, 529,  660,  621,  1401, 1477,
        211,  1152, 136,  505,  477,  362,  1270, 1800, 1105, 358,  219,  1477,
        1321, 2,    812,  345,  1785, 307,  26,   1628, 275,  1479, 215,  1018,
        277,  882,  1594, 1879, 920,  1465, 711,  1354, 992,  853,  569,  1721,
        723,  1315, 283,  1222, 1914, 1530, 1538, 400,  1703, 261,  729,  405,
        138,  685,  1433, 815,  617,  1793, 1169, 1980, 1983, 1876, 727,  1898,
        1830, 1043, 973,  1224, 841,  433,  1351, 1087, 259,  1242, 1641, 1328,
        1873, 215,  1884, 858,  350,  1753, 395,  415,  667,  404,  1027, 442,
        1923, 750,  1364, 1582, 1113, 758,  629,  284,  1834, 1106, 859,  1007,
        1704, 957,  1655, 515,  1087, 1063, 374,  624,  628,  1894, 1741, 1606,
        78,   1916, 1434, 1378, 415,  1817, 1704, 1827, 388,  229,  1454, 1258,
        188,  720,  483,  136,  1572, 1845, 1021, 656,  306,  1996, 1956, 1424,
        1033, 27,   510,  688,  1350, 1717, 93,   317,  12,   1356, 1256, 1018,
        670,  214,  804,  1968, 728,  961,  673,  58,   674,  1059, 1831, 739,
        310,  1025, 515,  894,  175,  2000, 904,  1898, 21,   1411, 1091, 1930,
        1713, 1424, 1498, 1215, 1071, 1597, 1321, 720,  894,  587,  1926, 1068,
        1741, 1284, 678,  1661, 1464, 33,   1052, 1455, 1461, 825,  1231, 506,
        1259, 498,  614,  827,  1907, 1410, 1550, 1851, 865,  908,  230,  1373,
        1808, 794,  774,  1142, 1733, 1209, 1534, 1306, 520,  171,  811,  284,
        1384, 47,   81,   720,  1939, 1107, 1632, 1814, 424,  1641, 1640, 1212,
        1125, 1,    60,   433,  1962, 1020, 1452, 1301, 1982, 105,  1001, 956,
        190,  1860, 70,   574,  620,  478,  1543, 1433, 1889, 1424, 133,  428,
        1572, 1332, 302,  1396, 1916, 243,  808,  220,  564,  935,  1936, 1876,
        1988, 201,  1589, 77,   696,  179,  1904, 1415, 339,  1333, 333,  1450,
        1263, 1969, 1845, 1301, 51,   412,  1656, 1729, 1940, 643,  1933, 1864,
        1000, 468,  1300, 1136, 498,  80,   546,  107,  1912, 935,  1532, 1656,
        622,  790,  853,  888,  995,  436,  1414, 1579, 791,  152,  366,  248,
        1676, 1171, 1353, 1303, 1520, 1131, 684,  17,   828,  464,  1762, 1177,
        1678, 365,  1305, 1643, 948,  1187, 1526, 333,  616,  96,   1033, 1907,
        1860, 1406, 392,  916,  225,  248,  566,  1436, 1074, 1219, 1243, 1315,
        1492, 690,  1121, 834,  120,  1990, 1903, 1705, 833,  521,  324,  1934,
        817,  367,  831,  1310, 449,  1864, 31,   6,    1266, 1949, 1001, 840,
        820,  669,  830,  545,  1570, 91,   297,  1348, 1146, 1967, 934,  811,
        158,  1247, 336,  446,  793};

      size_t num_blocks = cost_list.size();
      CAPTURE(num_blocks);
      REQUIRE(num_blocks == 1001);

      CAPTURE(cost_list);
      std::vector<Block_Cost> block_costs;
      block_costs.reserve(num_blocks);
      for(size_t index = 0; index < num_blocks; ++index)
        {
          block_costs.emplace_back(cost_list.at(index), index);
        }

      do_test_block_mapping(procs_per_node, num_nodes, block_costs);
    }
  }
}